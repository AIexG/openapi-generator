/**
 * @Name {{appName}} {{appVersion}}
 * @Date {{generatedDate}}
 * @Description {{appDescription}}
 *
 * Automatically generated interface
 **/

#include "stdafx.h"
#include "CppDllServer.h"

{{#hasEnums}}
/**
 * ENUM declaration, all unique enums used in the OpenAPI specification
 **/
{{#uniqueEnums}}
static const std::vector<std::string> i{{name}} = {""{{#values}}, "{{this}}"{{/values}}};
{{/uniqueEnums}}
{{/hasEnums}}

/**
 * @fn ST_STRING::ST_STRING
 * @param data String to be copied and stored in the struct
 * @brief Constructor for struct ST_STRING
 **/
ST_STRING::ST_STRING(std::string const &data)
{
	data.copy(szData, MIN(data.size(), sizeof(szData) / sizeof(szData[0]) - 1));
}

/**
 * @fn ST_BASE::handleAdditionalProperties
 * @param ct A property tree iterator
 * @param mParams A structs map for additinal values
 **/
void ST_BASE::handleAdditionalProperties(std::pair<const std::string, boost::property_tree::ptree> const &ct, std::map<std::string, ST_STRING> &mParams)
{
	// Node is a terminal value (No children && has data)
	if (ct.second.empty() && !ct.second.data().empty())
	{
		mParams.emplace(ct.first.data(), ST_STRING(ct.second.data()));
	}
}

/**
 * @fn ST_BASE::handlePropertyArrayOfSchemas
 * @param pt The property tree
 * @param vector A vector of type T containing function fromPropertyTree()
 * @param szName JSON key name as string 
 * @param ulSize Reference to an integer containing vector size
 * @return false if an error has occured, missing a required parameter
 **/
template<typename T>
bool ST_BASE::handlePropertyArrayOfSchemas(boost::property_tree::ptree const &pt, std::vector<T> &vector, std::string const &szName, unsigned long &ulSize)
{
	bool bOutput = true;
	if (pt.get_child_optional(szName))
	{
		for (const auto &childTree : pt.get_child(szName))
		{
			vector.emplace_back();
			bOutput = vector.back().fromPropertyTree(childTree.second);
			if (!bOutput)
			{
				break;
			}
		}
		ulSize = vector.size();
	}
	return bOutput;
}

/**
 * @fn ST_BASE::handlePropertySchema
 * @param pt The property tree
 * @param property A property of type T containing function fromPropertyTree()
 * @param szName JSON key name as string
 * @return false if an error has occured, missing a required parameter
 **/
template<typename T>
bool ST_BASE::handlePropertySchema(boost::property_tree::ptree const &pt, T &property, const std::string &szName, bool bRequired)
{
	bool bOutput = true;
	if (!bRequired || pt.get_child_optional(szName)) {
		bOutput = property.fromPropertyTree(pt.get_child(szName));
	}
	else
	{
		bOutput = false;
	}
	return bOutput;
}

{{#models}}
{{#model}}

/**
 * @fn ST_{{classVarName}}::fromPropertyTree
 * @param pt The property tree
 * @return boolean, returns false if an error has occured (e.g. missing a required parameter)
 **/
bool ST_{{classVarName}}::fromPropertyTree(boost::property_tree::ptree const &pt)
{
	bool bOutput = true;
	std::vector<std::string> vVisited;

{{#vars}}
{{#required}}
	if (!pt.get_child_optional("{{baseName}}"))
	{
		return false; // reqired parameter {{baseName}} is missing
	}
{{/required}}
{{/vars}}
{{#vars}}
{{^isContainer}}
{{#isPrimitiveType}}
{{#isBoolean}}
	b{{name}} = pt.get("{{baseName}}", {{{defaultValue}}});
	ulSize += sizeof(b{{name}});
{{/isBoolean}}
{{#isFloat}}
	f{{name}} = pt.get("{{baseName}}", {{{defaultValue}}});
	ulSize += sizeof(f{{name}});
{{/isFloat}}
{{#isLong}}
	l{{name}} = pt.get("{{baseName}}", {{{defaultValue}}});
	ulSize += sizeof(l{{name}});
{{/isLong}}
{{#isDouble}}
	d{{name}} = pt.get("{{baseName}}", {{{defaultValue}}});
	ulSize += sizeof(d{{name}});
{{/isDouble}}
{{#isInteger}}
	i{{name}} = pt.get("{{baseName}}", {{{defaultValue}}});
	ulSize += sizeof(i{{name}});
{{/isInteger}}
{{#isNumber}}
{{^isFloat}}
{{^isLong}}
{{^isDouble}}
{{^isInteger}}
	d{{name}} = pt.get("{{baseName}}", {{{defaultValue}}});
	ulSize += sizeof(d{{name}});
{{/isInteger}}
{{/isDouble}}
{{/isLong}}
{{/isFloat}}
{{/isNumber}}
{{/isPrimitiveType}}
{{^isPrimitiveType}}
{{#isString}}
{{^isEnum}}
	pt.get("{{baseName}}", {{{defaultValue}}}).copy(sz{{name}}, MIN(pt.get("{{baseName}}", {{{defaultValue}}}).size(), sizeof(sz{{name}}) / sizeof(sz{{name}}[0]) - 1));
	ulSize += sizeof(sz{{name}});
	vVisited.emplace_back("{{baseName}}");
{{/isEnum}}
{{#isEnum}}
	i{{name}} = std::distance(i{{datatypeWithEnum}}.begin(), std::find(i{{datatypeWithEnum}}.begin(), i{{datatypeWithEnum}}.end(), pt.get("{{baseName}}", {{{defaultValue}}})));
	ulSize += sizeof(i{{name}});
	vVisited.emplace_back("{{baseName}}");
{{/isEnum}}
{{/isString}}
{{#isDate}}
	pt.get("{{baseName}}", {{{defaultValue}}}).copy(sz{{name}}, MIN(pt.get("{{baseName}}", {{{defaultValue}}}).size(), sizeof(sz{{name}}) / sizeof(sz{{name}}[0]) - 1));
	ulSize += sizeof(sz{{name}});
	vVisited.emplace_back("{{baseName}}");
{{/isDate}}
{{#isDateTime}}
	pt.get("{{baseName}}", {{{defaultValue}}}).copy(sz{{name}}, MIN(pt.get("{{baseName}}", {{{defaultValue}}}).size(), sizeof(sz{{name}}) / sizeof(sz{{name}}[0]) - 1));
	ulSize += sizeof(sz{{name}});
	vVisited.emplace_back("{{baseName}}");
{{/isDateTime}}
{{#isModel}}
	if (bOutput && pt.get_child_optional("{{baseName}}"))
	{
		bOutput = handlePropertySchema(pt, {{name}}, "{{baseName}}", {{#required}}true{{/required}}{{^required}}false{{/required}});
	}
	ulSize += {{name}}.ulSize;
{{/isModel}}
{{/isPrimitiveType}}
{{/isContainer}}
{{#isContainer}}
{{#isModelContainer}}
	if (bOutput && pt.get_child_optional("{{baseName}}"))
	{
		bOutput = handlePropertyArrayOfSchemas(pt, v{{name}}, "{{baseName}}", ul{{name}}Size);
	}
	ulSize += ul{{name}}Size;
{{/isModelContainer}}
{{^isModelContainer}}
	if (bOutput && pt.get_child_optional("{{baseName}}"))
	{
		for (const auto &childTree : pt.get_child("{{baseName}}"))
		{
{{#mostInnerItems}}
{{#isString}}
			v{{name}}.emplace_back();
			childTree.second.data().copy(v{{name}}.back().szData, MIN(childTree.second.data().size(), sizeof(v{{name}}.back().szData) / sizeof(v{{name}}.back().szData[0]) - 1));
{{/isString}}
{{^isString}}
			v{{name}}.emplace_back({{^isFloat}}{{^isLong}}{{^isInteger}}std::stod{{/isInteger}}{{/isLong}}{{/isFloat}}{{#isDouble}}std::stod{{/isDouble}}{{#isFloat}}std::stof{{/isFloat}}{{#isInteger}}std::stoi{{/isInteger}}{{#isLong}}std::stol{{/isLong}}(childTree.second.data()));{{/isString}}
{{/mostInnerItems}}
		}
		ul{{name}}Size = v{{name}}.size();
	}
	ulSize += ul{{name}}Size;
{{/isModelContainer}}
{{/isContainer}}
{{#isContainer}}
{{#isModel}}
	}
{{/isModel}}
{{/isContainer}}
{{^isString}}
{{^isDate}}
{{^isDateTime}}
	vVisited.emplace_back("{{baseName}}");
{{/isDateTime}}
{{/isDate}}
{{/isString}}
{{/vars}}
	for (const auto &ct : pt)
	{
		if (std::find(vVisited.begin(), vVisited.end(), ct.first.data()) == vVisited.end())
		{
			handleAdditionalProperties(ct, mAdditionalParams);
		}
	}
	ulAdditionalParamsSize = mAdditionalParams.size();

	return bOutput;
}

{{/model}}
{{/models}}