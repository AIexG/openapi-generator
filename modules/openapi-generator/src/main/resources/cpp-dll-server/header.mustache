/**
 * @Name {{appName}} {{appVersion}}
 * @Date {{generatedDate}}
 * @Description {{appDescription}}
 *
 * Automatically generated interface
 **/

#ifndef MIN
#define MIN(a,b)	(((a) < (b)) ? (a) : (b))
#endif /* MIN */

#include <vector>
#include <map>
#include <string>
#include <boost/property_tree/ptree.hpp>
{{#imports}}{{{import}}}
{{/imports}}

/**
 * @struct ST_STRING
 * @brief Structure containing a single c style string
 **/
typedef struct ST_STRING {
	char szData[64] = {0};
	ST_STRING() {};
	ST_STRING(std::string const &data);
} ST_STRING;

/**
 * @struct ST_BASE
 * @brief Provides base functionality to structs
 **/
typedef struct ST_BASE {
	unsigned long ulSize = 0;
	unsigned long ulAdditionalParamsSize;
	std::map<std::string, ST_STRING> mAdditionalParams;
protected:
	void handleAdditionalProperties(std::pair<const std::string, boost::property_tree::ptree> const &ct, std::map<std::string, ST_STRING> &mParams);
	template<typename T>
	bool handlePropertyArrayOfSchemas(boost::property_tree::ptree const &pt, std::vector<T> &vector, std::string const &szName, unsigned long &ulSize);
	template<typename T>
	bool handlePropertySchema(boost::property_tree::ptree const &pt, T &property, const std::string &szName, bool bRequired = false);
} ST_BASE;

/**
 * Order of automatically generated TestOrder structs:
 *
{{#models}}
{{#model}}
 * - {{classVarName}}
{{/model}}
{{/models}}
 **/

{{#models}}
{{#model}}/**
 * @struct ST_{{classVarName}}
 * @brief {{description}}
 *
 * This structure must have the same format and size
 * as the mode specific structure in the ODX-Service.
 * It is used to pass parameters for the action
{{#circularReferences}} *
 * requires {{{this}}};{{/circularReferences}} **/
#pragma pack(push)
#pragma pack(1)
typedef struct ST_{{classVarName}} : public ST_BASE {
{{#vars}}
{{^isContainer}}
{{#isPrimitiveType}}
{{#isBoolean}}
	bool b{{name}};
{{/isBoolean}}
{{#isFloat}}
	float f{{name}};
{{/isFloat}}
{{#isLong}}
	long l{{name}};
{{/isLong}}
{{#isDouble}}
	double d{{name}};
{{/isDouble}}
{{#isInteger}}
	int i{{name}};
{{/isInteger}}
{{#isNumber}}
{{^isFloat}}
{{^isLong}}
{{^isDouble}}
{{^isInteger}}
	double d{{name}};
{{/isInteger}}
{{/isDouble}}
{{/isLong}}
{{/isFloat}}
{{/isNumber}}
{{/isPrimitiveType}}
{{^isPrimitiveType}}
{{#isString}}
{{^isEnum}}
	char sz{{name}}[64] = {0};
{{/isEnum}}
{{#isEnum}}
	unsigned short i{{name}}; //ENUM:{{#_enum}} {{.}}{{/_enum}}
{{/isEnum}}
{{/isString}}
{{#isDate}}
	char sz{{name}}[11] = {0}; // Date
{{/isDate}}
{{#isDateTime}}
	char sz{{name}}[21] = {0}; // Datetime
{{/isDateTime}}
{{#isModel}}
	ST_{{complexType}} {{name}};
{{/isModel}}
{{/isPrimitiveType}}
{{/isContainer}}
{{#isContainer}}
{{#mostInnerItems}}
{{#isModel}}
	unsigned long ul{{name}}Size;
	std::vector<ST_{{complexType}}> v{{name}};
{{/isModel}}
{{^isModel}}
{{#isString}}
	unsigned long ul{{name}}Size;
	std::vector<ST_STRING> v{{name}};
{{/isString}}
{{#isFloat}}
	unsigned long ul{{name}}Size;
	std::vector<float> v{{name}};
{{/isFloat}}
{{#isLong}}
	unsigned long ul{{name}}Size;
	std::vector<long> v{{name}};
{{/isLong}}
{{#isDouble}}
	unsigned long ul{{name}}Size;
	std::vector<double> v{{name}};
{{/isDouble}}
{{#isInteger}}
	unsigned long ul{{name}}Size;
	std::vector<int> v{{name}};
{{/isInteger}}
{{/isModel}}
{{/mostInnerItems}}
{{/isContainer}}
{{/vars}}
	bool fromPropertyTree(boost::property_tree::ptree const &pt);
} ST_{{classVarName}};
#pragma pack(pop)

{{/model}}
{{/models}}